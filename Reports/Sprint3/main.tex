%% This is file `elsarticle-template-1-num.tex',
%%
%% Copyright 2009 Elsevier Ltd
%%
%% This file is part of the 'Elsarticle Bundle'.
%% ---------------------------------------------
%%
%% It may be distributed under the conditions of the LaTeX Project Public
%% License, either version 1.2 of this license or (at your option) any
%% later version.  The latest version of this license is in
%%    http://www.latex-project.org/lppl.txt
%% and version 1.2 or later is part of all distributions of LaTeX
%% version 1999/12/01 or later.
%%
%% Template article for Elsevier's document class `elsarticle'
%% with numbered style bibliographic references
%%
%% $Id: elsarticle-template-1-num.tex 149 2009-10-08 05:01:15Z rishi $
%% $URL: http://lenova.river-valley.com/svn/elsbst/trunk/elsarticle-template-1-num.tex $
%%
\documentclass[preprint,12pt]{elsarticle}

%% Use the option review to obtain double line spacing
%% \documentclass[preprint,review,12pt]{elsarticle}

%% Use the options 1p,twocolumn; 3p; 3p,twocolumn; 5p; or 5p,twocolumn
%% for a journal layout:
%% \documentclass[final,1p,times]{elsarticle}
%% \documentclass[final,1p,times,twocolumn]{elsarticle}
%% \documentclass[final,3p,times]{elsarticle}
%% \documentclass[final,3p,times,twocolumn]{elsarticle}
%% \documentclass[final,5p,times]{elsarticle}
%% \documentclass[final,5p,times,twocolumn]{elsarticle}

%% The graphicx package provides the includegraphics command.
\usepackage{graphicx}
%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
\usepackage{float}
\usepackage{amsmath}
%% The amsthm package provides extended theorem environments
%% \usepackage{amsthm}

%% The lineno packages adds line numbers. Start line numbering with
%% \begin{linenumbers}, end it with \end{linenumbers}. Or switch it on
%% for the whole article with \linenumbers after \end{frontmatter}.
\usepackage{lineno}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    citecolor=blue,
    urlcolor=blue,
}
\usepackage{multimedia}
\usepackage{attachfile2}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning,fit}
\usepackage{listings}
\usepackage{xcolor}
\lstset{
  basicstyle=\ttfamily\small,
  frame=single,
  breaklines=false,
  columns=fullflexible,
  keepspaces=true
}

% Define JSON language for listings
\lstdefinelanguage{json}{
  basicstyle=\ttfamily\small,
  numbers=none,
  numberstyle=\scriptsize,
  stepnumber=1,
  numbersep=8pt,
  showstringspaces=false,
  breaklines=true,
  frame=lines,
  string=[s]{"}{"},
  comment=[l]{:\ "},
  morecomment=[l]{:"},
  literate=
    *{0}{{{\color{blue}0}}}{1}
     {1}{{{\color{blue}1}}}{1}
     {2}{{{\color{blue}2}}}{1}
     {3}{{{\color{blue}3}}}{1}
     {4}{{{\color{blue}4}}}{1}
     {5}{{{\color{blue}5}}}{1}
     {6}{{{\color{blue}6}}}{1}
     {7}{{{\color{blue}7}}}{1}
     {8}{{{\color{blue}8}}}{1}
     {9}{{{\color{blue}9}}}{1}
}

%% natbib.sty is loaded by default. However, natbib options Fcan be
%% provided with \biboptions{...} command. Following options are
%% valid:

%%   round  -  round parentheses are used (default)
%%   square -  square brackets are used   [option]
%%   curly  -  curly braces are used      {option}
%%   angle  -  angle brackets are used    <option>
%%   semicolon  -  multiple citations separated by semi-colon
%%   colon  - same as semicolon, an earlier confusion
%%   comma  -  separated by comma
%%   numbers-  selects numerical citations
%%   super  -  numerical citations as superscripts
%%   sort   -  sorts multiple citations according to order in ref. list
%%   sort&compress   -  like sort, but also compresses numerical citations
%%   compress - compresses without sorting
%%
%% \biboptions{comma,round}

% \biboptions{}

\journal{NDVW Sprint 3}

\begin{document}


\begin{titlepage}
    \centering
    \vspace*{1cm}

    % University Logo
    \includegraphics[width=0.3\textwidth]{figures/ub_logo.png}

    \vspace{1.5cm}
    {\Huge\bfseries NDVW Final Report\par}
    \vspace{1cm}
    {\large Procedurally Generated 2D RPG with AI-Driven Narrative\par}
    \vspace{2cm}
    {\large\bfseries Group 3:\par}
    \vspace{0.2cm}
    {\large Oriol MIR\'O, Jean DI\'E, Bruno S\'ANCHEZ, D\'aniel M\'ACSAI\par}
    \vspace{3cm}
    {\large \textbf{Master in Artificial Intelligence}\par}
    \vspace{0.5cm}
    {\large \textbf{Normative and Dynamic Virtual Worlds}\\ Final Report (Sprint 3)\par}
    \vspace{1cm}
    {\large\bfseries December 16th, 2025\par}
\end{titlepage}


%%
%% Start line numbering here if you want
%%
%\linenumbers

%% main text
\section{Introduction}
\label{S:1}

\subsection{General Overview}

The project involves developing a simple 2D top-down game in which a player navigates a procedurally generated dungeon filled with enemies, obstacles, and various NPCs. 
Our goal is to generate almost every element of the game procedurally, from the layout of the dungeon, to the story -- within some bounds, of course --  and even the ambient music.
The main challenge is to make all this generated content consistent, which requires designing a generation pipeline.
Moreover, we designed a story so that it is explained \emph{why} so many things change across runs.
There is three parts to the story, each with a boss at the end. 
Defeating each boss also serves as a checkpoint, and the generated story and dungeon are frozen up to that point. 
See Figure~\ref{fig:game_flow} for a schematic representation of this.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figures/game_flow.png}
    \caption{Three dungeon chapters, each ending in a boss fight. Defeating bosses 1 and 2 seals solves chapter (layout and story become fixed). Upon death, the player respawns at the start of the current unsolved chapter; solved chapters remain unchanged.}
    \label{fig:game_flow}
\end{figure}

\paragraph{Where is the AI in this game?}
We build the baseline gameplay loop (movement, combat, weapons, UI) from the tutorial in Section~\ref{sec:tutorial}. 
On top of that baseline, our project contributions are the AI-driven systems:

\begin{itemize}
    \item \textbf{PCG (Dungeon + population):} 
      BSP-based layout generation + connectivity, plus room interior/population (incl.\ cellular automata) to create different dungeon structures across runs.
    \item \textbf{GenAI (Narrative + Music):} 
      We analyze room screenshots (vision) to produce structured descriptors, then generate NPC dialogue/quests/lore (LLM), and generate adaptive music conditioned on the same descriptors.
    \item \textbf{RL (Boss agents):} 
      Bosses are controlled by policies trained in a simplified combat environment, then deployed in-game to produce reactive, non-scripted encounters.
\end{itemize}

\paragraph{Contributions}
A detailed task allocation (who implemented what) is provided in Appendix~\ref{app:contrib}.

\subsection{Scenario}
\label{sec:scenario}

We now present the story of our game. The goal is to keep the lore tightly aligned with the mechanics: death regenerates content, and boss victories make what happened so far persistent.

Sir Cael is trapped inside a magic book that rewrites the dungeon every time he dies. 
The dungeon is split into three chapters, each one ending in a boss fight. 
When Cael dies, the book rewrites only the chapter he is currently in: rooms and encounters are rearranged into a new version of the same chapter, which explains the procedural regeneration across runs.

Defeating the bosses of Chapter 1 and Chapter 2 \emph{seals} those chapters. 
Once sealed, their layouts and narrative elements stop changing. 
If Cael dies later, the sealed chapters remain intact and only the current, unsealed chapter regenerates -- this justifies the checkpoint logic

In the final chapter, Cael confronts the Chronicler, the force behind the loop. If he wins, the rewriting stops and the story ends.

\subsubsection{Spoilers!}
Cael is the Chronicler. 
Long ago, he created the Chronicle to rewrite history until it was ``perfect'', but he ended up trapped in his own loop.
 Boss 1 and boss 2 are manifestations of what keeps him stuck (fear and denial), and sealing the first two chapters represents accepting those parts instead of rewriting them. 
 The final boss is Cael facing the part of himself that refuses to stop revising the story.


\subsection{Tutorial we start from}\label{sec:tutorial}

To accelerate development of the core mechanics, we base the initial phase of our project on the online tutorial course ``Unity 2D RPG: Complete Combat System'' (Unity 2D RPG: Complete Combat System) from Udemy.
All the information can be found in \href{https://www.udemy.com/course/unity-2d-rpg/?couponCode=MT251110G3}{this link}.
Figure~\ref{fig:ex_fig_tutorial} shows an example scene from the tutorial.
This tutorial guides us through creating a classic 2D top-down RPG in Unity using C\#. 
It covers topics such as player movement, tilemap and rule tile usage, weapon systems, and basic combat.
By using this foundation, we can focus our efforts on the AI side of the game rather than reinventing standard mechanics from scratch.

Specifically, the tutorial includes:
\begin{itemize}
  \item Basic 2D top-down player movement and animation (using tilemaps and rule tiles)  
  \item Implementation of a weapon-based combat system in Unity (including multiple weapons, attack animations, and hit detection)  
  \item Setting up scene workflow and tiled environments using Unity's tilemap features  
  \item Some C\# fundamentals tied to game logic in Unity (moving from beginner to intermediate level)  
\end{itemize}

What the tutorial does \textbf{not} cover (and which our project extends) includes:
\begin{itemize}
  \item Procedural content generation of dungeon layouts (BSP-based layout generator and CA-based room populator)  
  \item Narrative generation tied to player runs and persistent checkpointing of story chapters  
  \item Procedural ambient music generation and dynamic layering based on gameplay state  
  \item Reinforcement learning-based boss behavior trained through self-play  
  \item The novel ``checkpoint/hall of fixed chapters'' mechanic, where defeating bosses 1 and 2 freezes that portion of the dungeon and story  
\end{itemize}

All scenes in the tutorial are manually designed, and all the enemies' movement and attack patterns are random, not tied to any player input.

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{figures/example_from_tutorial.png}
    \caption{Example screenshot from the tutorial}
    \label{fig:ex_fig_tutorial}
\end{figure}


\subsection{Game Agents}

In this section, we describe the design and behavior of the various agents within the game. These agents, which include the player character, common enemies, and bosses, are crucial for creating a dynamic and engaging player experience. We will detail their underlying AI, movement patterns, and combat mechanics.

\subsubsection{Player Agent}

The player controls a knight character, navigating the dungeon and engaging in combat. The agent's mechanics (implemented following the tutorial mentioned in Section~\ref{sec:tutorial}) are designed to be intuitive and offer a variety of tactical options. Figure~\ref{fig:player_agent} shows the sprite for the hero.

\begin{figure}[H]
    \centering
    \includegraphics[height=0.2\linewidth]{figures/Hero_Idle.png}
    \caption{Sprite for the Player Agent.}
    \label{fig:player_agent}
\end{figure}

\paragraph{Movement and Abilities}
The player uses the standard WASD keys for top-down movement. Aiming is controlled by the mouse cursor, allowing for 360-degree targeting independent of movement direction. A key defensive ability is the dash, triggered by the space bar, which provides a short burst of invulnerability and speed. Dashing consumes stamina from a dedicated bar, which regenerates automatically over time, requiring players to manage its use strategically.

\paragraph{Combat and Weapons}
Attacks are initiated with a left-click. The player has access to three distinct weapons, which can be switched using the number keys (1-3):
\begin{itemize}
    \item \textbf{Sword (Key 1):} A melee weapon that performs a sweeping attack in a short arc in front of the player. It is ideal for close-quarters combat against multiple weak enemies. Deals 1 damage.
    \item \textbf{Bow (Key 2):} A long-range weapon that shoots a single arrow. The arrow is destroyed upon hitting an enemy, making it suited for picking off targets from a distance. Deals 1 damage.
    \item \textbf{Magic Staff (Key 3):} A medium-range weapon that fires a piercing beam of magic. The beam slowly travels through all enemies in its path, making it effective for dealing with lined-up groups. Deals 3 damage.
\end{itemize}
All successful attacks apply a knockback effect to enemies, providing a brief moment of crowd control and repositioning opportunity.

\paragraph{Health and Resources}
The player starts with 3 health points by default, represented by a health bar that decreases upon taking damage from enemy attacks. Health can be replenished by collecting hearts, which have a chance to drop from defeated enemies. Additionally, fallen enemies drop coins that can be collected.

\subsubsection{Basic Monsters Agents}

The behavior of common enemies is governed by a Finite State Machine (FSM) that dictates their actions based on the player's proximity. However, the main focus of our AI work in this project is on procedural content generation (PCG), generative AI, and reinforcement learning (RL) agents, which are introduced and covered in detail in later sections. As such, the FSM governing the basic monsters is purely inherited from the base game and intentionally kept very simple.

Each enemy agent operates in one of two states: \texttt{Roaming} or \texttt{Attacking}. When in the \texttt{Roaming} state, the enemy moves to randomly generated points within the dungeon. If the player enters a predefined \texttt{attackRange}, the enemy transitions to the \texttt{Attacking} state. While attacking, each enemy is subject to an \texttt{attackCooldown} timer, which prevents it from attacking continuously and enforces a minimum delay between consecutive attacks. The enemy will remain in the \texttt{Attacking} state until the player moves out of range, at which point it returns to \texttt{Roaming}. Figure~\ref{fig:enemy_fsm} illustrates the finite state machine (FSM) governing enemy behavior. The diagram shows the two main states (\texttt{Roaming} and \texttt{Attacking}) and the transitions triggered by the player's proximity.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\linewidth]{figures/EnemyAI FSM.png}
  \caption{Finite State Machine (FSM) for enemy agents. Enemies switch between \texttt{Roaming} and \texttt{Attacking} states based on the player's distance.}
  \label{fig:enemy_fsm}
\end{figure}

Currently, there are two types of enemies implemented, as shown in Figure~\ref{fig:enemy_sprites}:

\begin{itemize}
    \item \textbf{Slimes:} These enemies represent the simplest form of the FSM. They do not have an explicit attack action. Instead, their ``attack'' is passive; they damage the player upon contact. Their \texttt{attackRange} is very small, meaning they only transition to the \texttt{Attacking} state when the player is nearly touching them, at which point contact damage is applied.
    \item \textbf{Ghosts:} These enemies are shooters that engage the player from a distance. When they enter the \texttt{Attacking} state, they trigger a shooting behavior. They can be configured to fire a burst of projectiles in a wide arc or in an oscillating, wave-like pattern. This allows for varied combat encounters depending on the specific instance of the Ghost enemy.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[height=0.1\linewidth]{figures/Slime_Sheet.png}
    \includegraphics[height=0.1\linewidth]{figures/Ghost.png}
    \caption{Sprites for the Slime (left) and Ghost (right) enemies.}
    \label{fig:enemy_sprites}
\end{figure}

\subsubsection{Boss Agents}\label{sec:boss_agents}

The three main bosses in the game are designed to be significant challenges that test the player's skill. Their behavior is controlled by agents trained using Reinforcement Learning (RL), allowing them to react to the player's actions and create dynamic, unscripted encounters.

Our approach is to model the boss agents as enhanced, hostile versions of the player character. At their core, these bosses possess a similar set of abilities as the player's knight, but they are controlled by a trained RL agent.

Unlike the player, boss agents only have access to the Sword weapon; however, to compensate for this limitation, we increased their health points (7 HP instead of the player's 3), and their movement speed (from 4 to 5). To make them more menacing and visually distinct, we gave them a different color palette (see Figure~\ref{fig:boss_agent}).

\begin{figure}[H]
    \centering
    \includegraphics[height=0.2\linewidth]{figures/Villain_Idle.png}
    \caption{Sprite for the Boss Agents.}
    \label{fig:boss_agent}
\end{figure}

The technical specifics of the training process, reward functions, and agent architecture for these bosses are detailed further in Section~\ref{sec:rl_proposal}.

\section{Related Work}

\paragraph{PCG}
Game design increasingly takes advantage of procedural content and AI-driven systems. 
Several roguelike-inspired action games -- notably \emph{The Binding of Isaac}, \emph{Spelunky}, \emph{Dead Cells} and \emph{Hades} -- use procedural algorithms such as binary space partitioning or cellular automata to assemble dungeons and item layouts at runtime, to have high replayability. Large open-world games like \emph{Minecraft} and \emph{No Man's Sky} show how flexible PCG is~\cite{shaker2016procedural}.

\paragraph{Narrative generation}
\emph{Middle-earth: Shadow of Mordor/Shadow of War} introduced the ``Nemesis'' system, in which orc captains are procedurally generated and remember past encounters; they can return with scars or new ranks, creating unique personal stories.
Earlier AI-driven titles such as \emph{Façade} and \emph{Versu} started dynamic dialogue and multiple endings, while Ubisoft's \emph{Watch Dogs: Legion} showed how to write a dynamic script: the narrative team wrote twenty variations of every line and tied each version to a procedurally generated persona (e.g., a policeman says ``much obliged'', a young activist says ``appreciate it, fam''). 
Simulation-heavy games like \emph{Dwarf Fortress} and \emph{RimWorld} are described as story generators because their complex systems of characters, needs and events produce emergent stories rather than fixed plots~\cite{liapis2013sentient,buongiorno2024pangea}.

\paragraph{Generative music}
Dynamic soundtracks have been explored in both indie and AAA games.
In \emph{No Man's Sky}, audio director Paul Weir and the band 65daysofstatic created hundreds of musical fragments tagged by key, tempo and mood; the game's ``Pulse'' tool combines these elements in real time to generate soundscapes that react to what the player is doing.
A decade earlier, Brian Eno composed a fully procedural score for \emph{Spore}, making the game's music as generative as its evolving life forms~\cite{castellon2023generative}.

\paragraph{Reinforcement learning agents}
While many shipped games focus on hand-authored AI behaviors or simple difficulty scaling, there is a growing body of work exploring reinforcement learning (RL) agents trained for complex control tasks. AlphaStar, for example, used large-scale self-play to learn high-level strategies and unit micro-management in \emph{StarCraft II}, producing agents that could compete with professional players~\cite{vinyals2019alphastar}. Similarly, the Visual Doom AI Competitions challenged participants to train agents directly from raw pixels in \emph{Doom}, where the strongest entries relied on deep RL methods to achieve competitive performance~\cite{Wydmuch_2019}.


\section{Proposal}

The design of our game relies on a combination of procedural content generation (PCG) and adaptive AI systems to ensure that every run feels unique yet narratively coherent. 
The following subsections describe the main AI components that create the dungeon structure, generate narrative, generate adaptive music, and control enemy and boss behaviors.

\subsection{Procedural Dungeon Generation}
\label{subsec:procedural_dungeon}

\subsubsection{Dungeon Run Manager, Connectivity Modes, and BSP Generation}
\label{subsubsec:bsp_layout}

We first describe the \texttt{DungeonRunManager}, which orchestrates chapter progression and regeneration. We then describe how each chapter dungeon is generated using BSP and (internally) connected via corridors or (optionally) portals. Full pseudocode is given in Appendix~\ref{app:pcg_pseudocode}.

\paragraph{DungeonRunManager (chapter seeds, persistence, and transitions)}
The run is split into three chapters. At the start of the run, \texttt{DungeonRunManager} samples and stores a \texttt{layoutSeed} for each chapter. When loading a chapter, it applies the corresponding theme (see \ref{subsubsec:ca_rooms} and calls \\ \texttt{GenerateWithSeedAndPlacePlayer(seed)}. The manager also enforces persistence: defeating a boss marks the chapter as completed and updates a checkpoint index. On player death, if the player is past the last completed chapter, only the current chapter seed is resampled and regenerated; completed chapters remain unchanged.

\paragraph{Connectivity: corridors vs.\ portals}
We treat connectivity as a first-class choice because it affects both gameplay readability and our GenAI pipeline (Section \ref{subsec:genai_pipeline}). In \emph{corridor mode}, the generator physically carves paths between rooms, producing classic dungeon traversal. In \emph{portal mode}, connected rooms are linked by a portal transition, optionally reducing long camera confiner corridors and making room boundaries cleaner. We considered portal connectivity because: (i) it matches our asset set (portals already exist and look better than very long corridors in a small tileset),(ii) it makes it easier to capture consistent screenshots for GenAI (clean room views with fewer transitional hallway artefacts).

\begin{figure}[H]
  \centering
  \begin{minipage}[t]{0.48\linewidth}
    \centering
    \includegraphics[width=\linewidth]{figures/corridor_example.png}
    \caption{Corridor connectivity between rooms.}
    \label{fig:corridor_example}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.48\linewidth}
    \centering
    \includegraphics[width=\linewidth]{figures/portal_example.png}
    \caption{Portal connectivity/exit portal example.}
    \label{fig:portal_example}
  \end{minipage}
\end{figure}

\paragraph{Boss-defeat exit portal}
Chapter progression is gated by an exit portal spawned only after the boss is defeated. Concretely, \texttt{OnBossDefeated()} marks the chapter as completed, shows a short victory UI, and calls \\ \texttt{SpawnChapterExitPortalAtBossRoom()}.This prevents skipping bosses, makes success visible to the player, and keeps transitions deterministic (use portal $\rightarrow$ \texttt{LoadChapter(current+1)}).

Figure~\ref{fig:run_transitions} shows the transition states controlled by \texttt{DungeonRunManager}.

\begin{figure}[H]
  \centering
  \begin{minipage}[t]{0.32\linewidth}
    \centering
    \includegraphics[width=\linewidth]{figures/death_screen.png}\\
    \small\textbf{(a)} Death screen (on player death).
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.32\linewidth}
    \centering
    \includegraphics[width=\linewidth]{figures/final_victory.png}\\
    \small\textbf{(b)} Final victory screen (after last boss).
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.32\linewidth}
    \centering
    \includegraphics[width=\linewidth]{figures/boss_portal.png}\\
    \small\textbf{(c)} Exit portal spawned after boss defeat.
  \end{minipage}

  \caption{Run transitions managed by \texttt{DungeonRunManager}: (a) death resets the current unsealed chapter, (b) final victory ends the run, and (c) boss defeat spawns the chapter exit portal.}
  \label{fig:run_transitions}
\end{figure}


\paragraph{BSP map layout generation}
Each chapter dungeon is generated by \\ \texttt{BSPMSTDungeonGenerator}. The generator operates on a grid of size \\ \texttt{mapWidth}$\times$\texttt{mapHeight}, recursively splits the space into rectangular leaves, and samples one room per terminal leaf when feasible. Splitting is adaptive to avoid degenerate leaves: letting $w=\texttt{bounds.width}$ and $h=\texttt{bounds.height}$, we bias the split orientation based on the aspect ratio ($w/h$ vs.\ $h/w$). Splits are only accepted if both children remain large enough (\texttt{minLeafSize}), so that we can later carve rooms of at least \texttt{minRoomSize} with margin.

\paragraph{Room carving}
For each terminal leaf, we compute candidate maxima
$\texttt{maxW}=\texttt{bounds.width}-2$ and $\texttt{maxH}=\texttt{bounds.height}-2$ and clamp them to $[\texttt{minRoomSize},\,\texttt{maxRoomSize}]$. If either is below \texttt{minRoomSize}, the leaf is skipped. Otherwise, room dimensions are sampled uniformly: \\
$\texttt{w}\sim\{\texttt{minRoomSize},\dots,\texttt{maxW}\}$ and
$\texttt{h}\sim\{\texttt{minRoomSize},\dots,\texttt{maxH}\}$,
and the bottom-left corner is sampled uniformly among valid placements so the room fits inside the leaf with a one-tile margin. Accepted rooms are painted to the tilemap and their floor cells are stored for subsequent wall placement and camera bounds.

\paragraph{Corridor graph (MST) and connectivity}
When using corridor mode, we connect rooms via a graph over room centres. For rooms $i,j$ with centres $\mathbf{c}_i,\mathbf{c}_j$, we assign edge weight
\[
w_{ij}=\lVert \mathbf{c}_i-\mathbf{c}_j\rVert_2.
\]
We compute a Minimum Spanning Tree using Kruskal's algorithm (Union-Find), guaranteeing that all rooms are reachable while minimizing total corridor length. Optionally, we add a small number of extra edges (short non-MST connections) to create loops and reduce linearity.

\paragraph{Walls, outside tiles, and camera bounds}
Finally, we place walls by inspecting neighbours around floor cells, fill a border of ``outside'' tiles to avoid empty camera regions, and derive camera confiner bounds from the generated floor region.



\input{sections/ca_room_population.tex}

% Include the GenAI pipeline section from external file
\input{sections/genai_pipeline.tex}

\input{sections/rl_proposal.tex}

\section{Conclusion}
In this project, we aimed to build a 2D RPG where as much as possible is \emph{non-scripted} across runs. 
To that end, we combined three AI-driven components that replace hand-authored content at different levels: procedural generation for level structure and gameplay spaces (PCG), generative models for audio and narrative content (GenAI), and reinforcement learning for boss behaviour (RL). 
The key design requirement was not just variety, but \emph{playable} variety: regeneration must preserve navigation readability and prevent content clashes.

Our main system-level contribution is a chapter-based run structure with boss-gated checkpoints. Chapters act as the unit of persistence: after a boss is defeated, everything the player has cleared so far (layout, encounters, and generated content for that chapter) remains fixed for the rest of the run, while failures only trigger regeneration of the current, unfinished chapter. This preserves a sense of forward progress and stable pacing, while still delivering high replayability through controlled, localized randomness.

On the PCG side, we generate chapter layouts and then populate rooms with a theme-conditioned pipeline. 
Cellular automata is used to create organic clustering for features such as lakes, paths, and decorations, avoiding the artificial look of uniform random placement, while larger obstacles are placed with collision-aware sampling to preserve traversability. 

On the GenAI side, we use generative models to replace manually authored narrative and audio while keeping outputs consistent with the current chapter theme. Rather than generating content per room (which is brittle under frequent regeneration), we generate chapter-scoped narrator lines, ambient music, and voice that remain stable within a chapter instance and therefore do not contradict what the player is seeing. This design makes the generated content feel intentional instead of noisy, and it avoids runtime latency or mid-run tone shifts that would hurt playability.

Finally, the Reinforcement Learning component demonstrated that boss agents can learn complex combat behaviors without explicit scripting. Our experiments showed that a two-phase training strategy (pre-training against a heuristic opponent followed by self-play refinement) was superior to pure self-play. This methodology prevented the agents from converging on passive strategies and produced bosses that actively pursue the player and utilize their full movement and attack capabilities.

Future work would focus on tighter integration between these distinct systems, such as allowing the RL agents' difficulty to influence the GenAI narrative, or using the PCG layout to constrain agent training environments dynamically. Nevertheless, this project successfully demonstrates that modern AI techniques can be orchestrated to build a game loop that is both structurally sound and creatively varied.


\bibliographystyle{model1-num-names}
\bibliography{references}

\newpage
\appendix
\section{Tasks Allocation}
\label{app:contrib}
The following is a breakdown of the main contributions made by each team member throughout the project:
\begin{itemize}
  \item \textbf{Oriol Miró}: Procedural dungeon generation (BSP implementation)
  \item \textbf{Dániel Mácsai}: Procedural room population, chapter theming (CA implementation)
  \item \textbf{Jean Dié}: Initial project setup, open-world prototype with basic procedural generation, and generative AI pipeline (narrative, music, and voice synthesis)
  \item \textbf{Bruno Sánchez}: Boss agents (Reinforcement Learning design and training)
\end{itemize}

\section{PCG Pseudocode}
\label{app:pcg_pseudocode}

\begin{lstlisting}[basicstyle=\ttfamily\small, frame=single]
Algorithm InitRun(runSeed, totalChapters):
  rng <- Random(runSeed)
  for k in 0..totalChapters-1:
    chapter[k].seed <- rng.NextInt()
    chapter[k].completed <- false
  checkpoint <- -1
  LoadChapter(0)

Algorithm LoadChapter(k):
  current <- k
  WorldGenerator.SetThemeForNextGeneration(chapterThemes[current])
  WorldGenerator.GenerateWithSeedAndPlacePlayer(chapter[current].seed)
  PlayerHealth.Reset()
  if current > 0: IntroductionDialogue.OnChapterEntered(current)

Algorithm OnBossDefeated():
  chapter[current].completed <- true
  checkpoint <- max(checkpoint, current)
  if current == totalChapters-1:
    TransitionUI.ShowFinalVictory(); return
  TransitionUI.ShowBossDefeatedText()
  WorldGenerator.SpawnChapterExitPortalAtBossRoom()

Algorithm UseChapterExit():
  if chapter[current].completed:
    LoadChapter(current + 1)

Algorithm OnPlayerDeath():
  TransitionUI.ShowDeathScreen(current)
  if current > checkpoint:
    chapter[current].seed <- rng.NextInt()   // regenerate only current chapter
  LoadChapter(current)

Algorithm GenerateWithSeedAndPlacePlayer(seed):
  rng <- Random(seed)
  ClearDungeon(); ApplyTheme()

  leaves <- BSP_Split(mapRect, rng, minLeafSize, roomCount)
  rooms  <- CarveRooms(leaves, rng, minRoomSize, maxRoomSize)
  edges  <- CompleteGraph(rooms, weight = centerDistance)
  conn   <- MST(edges) + ExtraEdges(edges, extraConnections)
  CarveCorridors(conn, rooms, rng)

  PlaceWallsOutsideAndCameraBounds()
  PopulateRooms(rooms, rng)

  PlacePlayer(StartRoom(rooms))
  PlaceBoss(BossRoom(rooms))                // boss room stored for portal spawn
\end{lstlisting}

\section{Generative AI Pipeline Details}
\label{app:genai_details}

This appendix provides additional technical details for the generative AI pipeline described in Section~\ref{subsec:genai_pipeline}.

\paragraph{Chapter Configuration}
Each chapter's generation parameters are defined in \texttt{config.json}:

\begin{lstlisting}[language=json, basicstyle=\ttfamily\scriptsize, frame=single]
{
  "seed": 54321,
  "models": {"narrative": "mistral-nemo", "music": "facebook/musicgen-small"},
  "chapters": [
    {
      "name": "The Verdant Prison",
      "boss": "Thornback",
      "environment": "sunlit forest with ancient trees and overgrown ruins",
      "progress_context": "This is the beginning. The player just arrived.",
      "music_prompt": "calm fantasy ambient music, gentle flute and strings,
                       forest atmosphere, mysterious, 90 bpm"
    },
    {"name": "The Eternal Night", "boss": "The Shade", ...},
    {"name": "The Burning End", "boss": "The Scorcher", ...}
  ]
}
\end{lstlisting}

\paragraph{Narrative Prompt Template}
The LLM receives the following prompt structure:

\begin{lstlisting}[basicstyle=\ttfamily\scriptsize, frame=single]
You are a fantasy game narrator with a deep, dramatic voice.
Setting: {chapter_name}. The boss is {boss}.
Context: {progress_context}

Write exactly 3 dramatic narrator lines (full sentences, 15-25 words each)
that set the mood and hint at the danger ahead. Be atmospheric and mysterious.
Output ONLY the 3 numbered lines:
1.
2.
3.
\end{lstlisting}

\paragraph{Example Output (Chapter 0 - The Verdant Prison)}

\begin{lstlisting}[basicstyle=\ttfamily\scriptsize, frame=single]
{
  "roomIndex": 0,
  "environment": "sunlit forest with ancient trees and overgrown ruins",
  "npc": {
    "name": "The Narrator",
    "dialogue": [
      "In the heart of the Verdant Prison, where whispers of ancient
       sorcery linger in the moss-kissed air...",
      "...the echoes of desperate pleas bounce off the living walls,
       swallowed by the relentless hum of unseen horrors.",
      "Beware, brave soul, for Thornback's shadows grow long..."
    ]
  },
  "quest": {"objective": "Defeat Thornback to proceed", "type": "Boss"},
  "lore": {"title": "The Verdant Prison", "content": "..."}
}
\end{lstlisting}

\paragraph{Output File Structure}
The generation script produces per chapter:

\begin{lstlisting}[basicstyle=\ttfamily\scriptsize, frame=single]
StreamingAssets/GeneratedContent/
  manifest.json           # Content manifest with seed
  chapters/
    chapter_0/
      narrative.json      # NPC name and dialogue lines
      music.wav           # 30-second loopable ambient track
      voice_0.wav         # Narrated dialogue lines
      voice_1.wav
      voice_2.wav
\end{lstlisting}

%% Authors are advised to submit their bibtex database files. They are
%% requested to list a bibtex style file in the manuscript if they do
%% not want to use model1-num-names.bst.

%% References without bibTeX database:

% \begin{thebibliography}{00}

%% \bibitem must have the following form:
%%   \bibitem{key}...
%%

% \bibitem{}

% \end{thebibliography}


\end{document}
